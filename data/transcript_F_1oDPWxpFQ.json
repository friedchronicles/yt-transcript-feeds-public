{"video_id": "F_1oDPWxpFQ", "title": "The AI Frontier: from Gemini 3 Deep Think distilling to Flash \u2014 Jeff Dean", "link": "https://www.youtube.com/watch?v=F_1oDPWxpFQ", "published": "2026-02-12T22:03:01+00:00", "summary": "From rewriting Google\u2019s search stack in the early 2000s to reviving sparse trillion-parameter models and co-designing TPUs with frontier ML research, Jeff Dean has quietly shaped nearly every layer of the modern AI stack. As Chief AI Scientist at Google and a driving force behind Gemini, Jeff has lived through multiple scaling revolutions from CPUs and sharded indices to multimodal models that reason across text, video, and code.\n\nJeff joins us to unpack what it really means to \u201cown the Pareto frontier,\u201d why distillation is the engine behind every Flash model breakthrough, how energy (in picojoules) not FLOPs is becoming the true bottleneck, what it was like leading the charge to unify all of Google\u2019s AI teams, and why the next leap won\u2019t come from bigger context windows alone, but from systems that give the illusion of attending to trillions of tokens.\n\nWe discuss:\n\u2022 Jeff\u2019s early neural net thesis in 1990: parallel training before it was cool, why he believed scaling would win decades early, and the \u201cbigger model, more data, better results\u201d mantra that held for 15 years\n\u2022 The evolution of Google Search: sharding, moving the entire index into memory in 2001, softening query semantics pre-LLMs, and why retrieval pipelines already resemble modern LLM systems\n\u2022 Pareto frontier strategy: why you need both frontier \u201cPro\u201d models and low-latency \u201cFlash\u201d models, and how distillation lets smaller models surpass prior generations\n\u2022 Distillation deep dive: ensembles \u2192 compression \u2192 logits as soft supervision, and why you need the biggest model to make the smallest one good\n\u2022 Latency as a first-class objective: why 10\u201350x lower latency changes UX entirely, and how future reasoning workloads will demand 10,000 tokens/sec\n\u2022 Energy-based thinking: picojoules per bit, why moving data costs 1000x more than a multiply, batching through the lens of energy, and speculative decoding as amortization\n\u2022 TPU co-design: predicting ML workloads 2\u20136 years out, speculative hardware features, precision reduction, sparsity, and the constant feedback loop between model architecture and silicon\n\u2022 Sparse models and \u201coutrageously large\u201d networks: trillions of parameters with 1\u20135% activation, and why sparsity was always the right abstraction\n\u2022 Unified vs. specialized models: abandoning symbolic systems, why general multimodal models tend to dominate vertical silos, and when vertical fine-tuning still makes sense\n\u2022 Long context and the illusion of scale: beyond needle-in-a-haystack benchmarks toward systems that narrow trillions of tokens to 117 relevant documents\n\u2022 Personalized AI: attending to your emails, photos, and documents (with permission), and why retrieval + reasoning will unlock deeply personal assistants\n\u2022 Coding agents: 50 AI interns, crisp specifications as a new core skill, and how ultra-low latency will reshape human\u2013agent collaboration\n\u2022 Why ideas still matter: transformers, sparsity, RL, hardware, systems \u2014 scaling wasn\u2019t blind; the pieces had to multiply together\n\nSubstack Article w/Show Notes: https://www.latent.space/p/jeffdean\n\n\u2014\n\nJeff Dean\n\u2022 LinkedIn: https://www.linkedin.com/in/jeff-dean-8b212555\n\u2022 X: https://x.com/jeffdean\n\nGoogle\n\u2022 https://google.com\n\u2022 https://deepmind.google\n\n00:00:00 Intro\n00:01:31 Frontier vs Flash & Distillation Strategy  \n00:05:09 Distillation, RL & Flash Economic Advantage  \n00:07:35 Flash in Products + Importance of Latency  \n00:11:11 Benchmarks, Long Context & Real Use Cases  \n00:15:01 Attending to Trillions of Tokens & Multimodality  \n00:20:11 LLM Search & Google Search Evolution  \n00:24:09 Systems Design Principles + Latency Numbers  \n00:32:09 Energy, Batching & TPU Co-Design  \n00:42:21 Research Frontiers: Reliability & RL Challenges  \n00:46:27 Unified Models vs Symbolic Systems (IMO)  \n00:50:38 Knowledge vs Reasoning + Vertical/Modular Models  \n00:55:58 Multilingual + Low-Resource Language Insights  \n00:57:58 Vision-Language Representations Example  \n01:07:15 Gemini Origin Story + Organizational Memo  \n01:09:27 Coding with AI & Agent Interaction Style  \n01:14:26 Prompting Skills & Spec Design  \n01:19:54 Latency Predictions & Tokens/sec Vision  \n01:21:29 Future Predictions: Personal Models & Hardware  \n01:23:11 Closing", "transcript_html": "<p><strong>[00:00]</strong></p>\n<p>[music] Hey everyone, welcome to the L in space podcast. This is Allesio, founder of Colonel Labs, and I'm joined by Swix, editor of L in Space. >> Hello. Hello. We're here in the studio with Jeff Dean, chief AI scientist at Google. Welcome. >> Thanks for having me. [laughter] >> It's a bit surreal to have you in the studio. I've I've watched so many of your talks uh and obviously uh you your career has been super legendary. So, uh I mean, congrats. I I think the the first thing must be said congrats on owning the Purto Frontier. [laughter] >> Thank you. Thank you. Parto Frontiers are good and it's good to be out there.</p>\n<p>>> Yeah. I mean I I think it's a combination of both uh your you have to own the Parto Frontier you have to have like frontier capability but also efficiency and then offer that range of models [snorts] that people like to use. uh and you know some part of this was started because of your hardware work some part of that is your model work and uh you know I'm sure there's lots of secret sauce that you guys uh have worked on uh accumulatively but like it's it's really impressive to see it all come together in like this steadily</p>\n<p>advancing frontier. >> Yeah. Yeah. I mean I think as you say it's not just one thing it's like a whole bunch of things up and down the stack >> and uh you know all of those really combined to help make you an OS able to make highly capable large models as well as you know software techniques to get those large model capabilities into much smaller lighter weight models that are you know much more cost-effective and lower latency but still you know quite capable for their size. So >> yeah, >> how how much pressure do you have on</p>\n<p>like having the lower bound of the prior frontier too? I think like the new labs are always trying to push the top performance frontier because they need to raise more money and all of that. And you guys have billions of users and I think initially when you work on the CPU you were thinking about you know if everybody that used Google we used the voice model for like 3 minutes a day they were like you need to double your CPU number like what's that discussion today at Google like how do you prioritize frontier versus like we actually need to deploy it if we build it. Yeah, I mean I think we always want</p>\n<p>to have models that are at the frontier or pushing the frontier because I think that's where you see what capabilities now exist that didn't exist at the sort of slightly less capable last year's version or last [clears throat] six months ago version. >> Um at the same time, you know, we know there those are going to be really useful for a bunch of use cases, but they're going to be uh a bit slower and a bit more expensive than people might like for a bunch of other broader use cases. So I think what we want to do is always have um kind of a highly capable</p>\n<p>uh sort of uh affordable model that enables a whole bunch of you know lower latency use cases. People can use them for agentic coding much more readily. Um and then have the the high-end you know frontier model that is really useful for um you know deep reasoning you know solving really complicated math problems those kinds of things. And and it's not</p>\n<p><strong>[03:01]</strong></p>\n<p>that one or the other is useful. They're both useful. So I think we like to do both. And also, you know, through distillation, which is a key technique for making the smaller models more capable, you know, you have to have the frontier model in order to then distill it into your your smaller model. So it's not like an either or choice. You sort of need that in order to actually get a highly capable more modest size model. >> Yeah. And I mean you and Jeffrey In came out with this solution in 2014. >> Don't forget L'Oreal Vine as well. a long time ago. Like >> I'm curious how you [snorts] think about</p>\n<p>the cycle of these ideas even like you know sparse models and uh you know how do you re-evaluate them? How do you think about in the next generational model what is worth revisiting like a yeah they're just kind of like a you know you worked on so many ideas that end up being influential but like in the moment they might not feel that way necessarily. Yeah, I mean I I think distillation was originally motivated because we were seeing that we had a very large image data set at the time, you know, 300 million images that we could train on with, you know, I forget like 20,000 categories or something, so</p>\n<p>much bigger than ImageNet. And we were seeing that if you create specialists for different subsets of those image categories, you know, this one's going to be really good at sort of mammals and this one's going to be really good at sort of indoor room scenes or whatever. and you can cluster those categories and train on an enriched stream of data after you do pre-training on on a much broader set of images. You get much better performance if you then treat that whole set of maybe 50 models you've trained as a large ensemble. Um but</p>\n<p>that's not a very practical thing to serve, >> right? So distillation really came about from the idea of okay what if we want to actually serve that and train all these independent sort of expert models um and then squish it into something that actually fits in a form factor that you can actually serve. And that's you know not that different from what we're doing today. You know often today we're instead of having an ensemble of 50 models we're having a much larger scale model that we then distill into a much smaller scale model.</p>\n<p>Yeah, a part of me also wonders if distillation also has a story with the RL um revolution. So what let me let me maybe try to articulate what I mean by that. uh which is you can uh RL basically spikes models in a certain uh part of the distribution and then you have to sort of well you can spike models but usually sometimes it might be lossy in other areas and it's kind of like an uneven technique but you can probably distill it back uh and you can</p>\n<p>uh I think that the sort of general um dream is to be able to advance capabilities without regressing on anything else >> and I think like that that whole capability merging without loss. Uh uh I feel like it's like you know some part of that should be a distillation process but I can't quite articulate it. I haven't seen much papers about it.</p>\n<p><strong>[06:02]</strong></p>\n<p>>> Yeah. I mean I I tend to think of one of the key advantages of distillation is that you can have a much smaller model and you can have a very large uh you know training data set and you can get utility out of making many passes over that data set because you're now getting the logits from the much larger model in order to sort of >> sort of coax the right behavior out of the smaller model uh that you don't wouldn't otherwise get with just the hard labels and and so um you know I think that's what we've observed is you can get, you know, clo very close to</p>\n<p>your largest model performance with distillation approaches. And that that seems to be, you know, a nice sweet spot for a lot of people because it enables us to kind of for multiple Gemini generations now, we've been able to make >> the sort of flash version of the next generation >> as good or even substantially better than the previous generations pro. And I think we're going to keep trying to do that because that seems like a good uh trend to follow. >> Um dare I ask uh so it was it was the original map was Flash Pro and Ultra.</p>\n<p>>> Uh is ultra are you just sitting on ultra and distilling from that? Is that like the mother load? [laughter] >> Uh I mean we have a lot of different kinds of models. Some are internal ones that are not necessarily meant to be released or served. Some are you know our pros scale model and we can distill from that as well into our flash scale model. So I think you know uh it's u it's an important set of capabilities to have and also inference time scaling can also be a useful thing to improve the capabilities of a model and >> yeah cool yeah and obviously I think the</p>\n<p>economy of flash is what led to the total dominance I think the the latest number is like 50 trillion uh tokens I I don't know I mean obviously it's changing every day >> but uh you know by market share >> hopefully hopefully up [laughter] >> no I mean there's no I mean Just the economics wise like uh because flash is so economical like you can use it for everything like it's in Gmail now it's in YouTube like it's it's in everything >> we're using it more in our search products of various AI mode overviews. >> Oh my god flash parts AI mode. Oh my god. Yeah that's yeah I didn't even</p>\n<p>think about that. >> Um [laughter] I mean I think one of the things that is uh quite nice about the flash model is not only is it more affordable it's also a lower latency. And I think latency is actually a pretty important characteristic for these models because we're going to want models to do much more complicated things that are going to involve, you know, generating many more tokens from when you ask the model to do something until it actually finishes what you ask it to do because you're going to ask now not just write me a for loop, but like write me a a whole software package to</p>\n<p>do X or Y or Z. And so having low latency systems that can do that uh seems really important. and flash is one direction, one one way of doing that. >> Yeah. >> You know, obviously our hardware platforms enable a bunch of interesting aspects of our, you know, serving stack as well like TPUs. Uh the interconnect between chips on the TPUs, uh is</p>\n<p><strong>[09:03]</strong></p>\n<p>actually quite quite high performance and quite amendable to for example long context kind of attention operations. You know, having sparse models with lots of experts. These kinds of things really really matter a lot in terms of how do you make them servable at scale. >> Yeah. Does it feel like there's some breaking point for like the protoflash distillation kind of like one generation delayed? I I almost think about almost like the capability asmtote in certain tasks like the pro model today is as saturated some sort of task. Mhm.</p>\n<p>>> So next generation that same task will be saturated at the flash price point and I think for most of the things that people use models for at some point the flash model in two generation will be able to do basically everything and how do you make it economical to like keep pushing the pro frontier when a lot of the population will be okay with the flash model? I'm curious how you think about that. >> I mean I think that's true if your distribution of what people are asking people the models to do is stationary, right? But I think what often happens is</p>\n<p>as the models become more capable, people ask them to do more, right? So I mean I think this happens in my own usage like I used to try our models a year ago for some sort of coding task and it was okay at some simpler things but wouldn't do work very well for more complicated things. And since then we've improved dramatically on the more on the more complicated coding tasks and now I'll ask it to do much more complicated things. And I think that's true not just of coding but of you know now you know can you analyze all the you know</p>\n<p>renewable energy uh deployments in the world and give me a report on solar panel deployment or whatever. That's a very complicated you know more complicated task than people would have asked a year ago. >> And so you are going to want more capable models to push the frontier in some sense of what people ask the models to do. And that also then gives us insight into okay where does the where do things break down? How can we improve the model in these these particular areas uh in order to sort of um make the next generation even better?</p>\n<p>>> Yeah. Are there any benchmarks or like test sets that you use internally? Because it's almost like the same benchmarks get reported every time and it's like all right it's like 99 instead of 97. Like how do you have to keep pushing the team internally too to like this is what we're building towards? >> Yeah. I mean, I think benchmarks, particularly external ones that are publicly available, have their utility, but they often kind of have a lifespan of utility where they're introduced and maybe they're quite hard for current models. You know, I I like to think of</p>\n<p>the best kinds of benchmarks are ones where the initial scores are like 10 to 20 or 30% maybe, but not higher. And then you can sort of work on improving that capability for uh whatever it is the benchmark is trying to assess and get it up to like 80 90% whatever. I I think once it hits kind of 95% or</p>\n<p><strong>[12:03]</strong></p>\n<p>something you get very diminishing returns from really focusing on that benchmark because it's sort of it's either the case that you've now achieved that capability [snorts] or there's also the issue of leakage in public data or very related kind of data being being in your training data. Um, so we have a bunch of held out internal benchmarks that we really look at where we know that wasn't represented in the training data at all. There are capabilities that we want the model to have um that it doesn't have now and then we can work on, you know, assessing, you know, how do we make the model better at these</p>\n<p>kinds of things? Is it we need different kind of data to train on that's more specialized for this particular kind of task? Do we need um you know a bunch of uh you know architectural improvements or some sort of uh model capability improvements? You know what would help make that better? >> Is there is there such an example that you uh a benchmark inspired an architectural improvement? like uh I'm just kind of jumping on that because you just >> uh I mean I think some of the long context capabilities of the of the Gemini models that came I guess first in</p>\n<p>1.5 >> really were about looking at okay we want to have um >> you know [clears throat] >> immediately everyone jumped to like completely green charts of like everyone had I was like how did everyone crack this at the same time like [laughter] >> right yeah I mean I think um and once you're set I mean as you say that needle single needle in a haststack benchmark is really saturated for at least context lengths up to 128k or something. I think most people >> don't actually have you know much larger than 128k these days or 256 or</p>\n<p>something. Um you know we're trying to push the frontier of 1 million or 2 million context language. >> I think Google's still the leader 2 million. >> Yep. which is good because I think there are a lot of use cases where you know putting a thousand pages of text or putting you know multiple you know hourlong videos in the context and then actually being able to make use of that is useful but the the single needle in a haststack benchmark is sort of saturated. Um so you really want more complicated uh sort of multi- needle or</p>\n<p>you know more realistic take all this content and produce this kind of answer from uh uh a long context that sort of better assesses what it is people really want to do with long context which is not just you know can you tell me the product number for this particular thing. >> Yeah it's retrieval it's it's retrieval within machine learning. Uh yeah, it's it's interesting because like I think that the more meta lesson level I'm trying to operate at here is uh you have a benchmark you're like okay I see the</p>\n<p>architectural thing I need to do in order to go fix that but like should you do it because sometimes you know that's an inductive bias basically that you're Jason we used to work at Google would say like exactly the kind of thing like yeah you're going to win short term longer term I don't know if that's going to scale you might have to undo that [laughter] >> I mean I I I like to sort of not focus</p>\n<p><strong>[15:05]</strong></p>\n<p>on exactly what solution one should drive but what capability would you want and I think we're very convinced that you know long context is useful but it's way too short today >> right like I think what you would really want is can I attend to the internet while I answer my question right [laughter] >> but that's not going to be solved by purely scaling the existing solutions which are quadratic so a million tokens kind of pushes >> uh what you can do you're not going to do that to a trillion tokens, let alone, you know, a billion tokens, let alone a</p>\n<p>trillion. Um, but I think if you could give the illusion that you can attend to trillions of tokens, that would be amazing. You'd be find all kinds of uses for that. You would have um attend to the internet. you could attend to the pixels of YouTube and the sort of deeper representations that we can form for a single video, but across many videos, you know, uh on a personal Gemini level, you could attend to all of your personal state with your permission. So like your emails, your photos, your</p>\n<p>>> yeah, >> your docs, your plane tickets you have. Um I I think that would be really really useful. And the question is, how do you get algorithmic improvements and system level improvements that get you to something where you actually can attend to trillions of tokens in some meaningful way? >> Yeah. But by the way, I think I I did some math and if like if you spoke all day every day for eight hours a day, um you only generate a maximum of like 100k tokens, which like very comfortably fits, [laughter]</p>\n<p>>> right? But if you then say okay I want to be able to um understand everything people are putting on video. >> Exactly. Exactly. Well also I think that the classic example is um you start going beyond language into like proteins and whatever else is extremely information dense. >> Yeah. >> Yeah. I mean, I think one of the things about Gemini's multimodal aspects is we've always wanted it to be multimodal from the start. And so, you know, that sometimes to people means</p>\n<p>text and images and video sort of humanlike and audio audio humanike modalities. But I think it's also really useful to have Gemini know about nonhuman modalities. like LAR sensor data from say Whimo vehicles or like robots or you know various kinds of health modalities, X-rays and MRIs and imaging and genomics information. Um and I think there's probably hundreds of modalities of data where you'd like the model to be able to at least be exposed</p>\n<p>to the fact that this is an interesting modality and has certain meaning in the world. uh where even if you haven't trained on all the LAR data or MRI data you could have because maybe that's not you know doesn't make sense in terms of trade-offs of you know what you include in your main pre-training data mix at least including a little bit of it is actually quite useful because it sort of >> uh tempts the model that this is a thing. >> Yeah. Yeah. Do do you believe I mean</p>\n<p><strong>[18:06]</strong></p>\n<p>since we're on this topic and something I just get to ask you all the questions I always wanted to ask which is fantastic. uh like there are there some king modalities like modalities that supersede all the other modalities. So the a simple example was vision um can on a pixel level encode text and deepc had this deepr paper that did that. Uh vision has also been shown to maybe incorporate audio because you can do audio spectrograms and that's that's also like a vision uh capable thing like so so maybe vision is just the king modality and like >> yeah I mean [laughter] vision and motion are quite important things right</p>\n<p>>> motion uh >> video as opposed to static images >> because I mean there's a reason evolution has evolved eyes like 23 independent ways because it's such a useful capability for sensing the world around you which is really what we want these models to be able to do is interpret the things we're seeing or the things we're we're paying attention to and then help us in uh using that information to to do things. >> Yeah, I I think motion uh you know I still want to shout out I think Gemini uh still the only native video</p>\n<p>understanding model that is out there. Uh so I use it for YouTube all the time. >> Yeah. Yeah. I mean, it's actually I think people kind of are not necessarily aware of what the Gemini models can actually do with video. Like, uh, I have an example I've used in one of my talks. >> It had like, uh, it was like a YouTube highlight video of 18 memorable sports moments across the last 20 years or something. So, it has like Michael Jordan hitting some jump shot at the end of the finals and, you know, some soccer uh, goals and things like that. And you</p>\n<p>can literally just give it the video and say, \"Can you please make me a table of what all these different events are, what when the date is, when they happened, and a short description of the event.\" And so you get like now an 18 row table of that information extracted from the video, which is, you know, not something most people think of as like a turn video into SQL like table. >> Yeah. Has there been any discussion inside of Google of like you mentioned</p>\n<p>tending to the whole internet? Right. Google it's almost built because the a human cannot tend to the whole internet and you need some sort of ranking to find what you need. >> Yep. >> That ranking is like much different for an LLM because you you can expect a person to look at maybe the first five six links in a Google search >> versus for an LLM should you expect to have 20 links that are highly relevant? like how do you internally figure out you know how do we build the AI mode that is like maybe like much broader >> search [clears throat] and span versus</p>\n<p>like the more human one. >> Yeah. I mean I think even pre- language model based work you know our ranking systems would be built to start with a giant number of web pages in our index. Many of them are not relevant. So you identify a subset of them that are relevant with very lightweight kinds of methods. Now you're down to like 30,000</p>\n<p><strong>[21:07]</strong></p>\n<p>documents or something. And then you have gradually refine that to apply more and more sophisticated algorithms and more and more sophisticated sort of signals of various kinds in order to get down to ultimately what you show which is you know the final 10 results or you know 10 results plus other kinds of information. And I think an LLM based system is not going to be that dissimilar, right? you're going to tend to trillions of tokens, but you're going to want to identify, you know, what are the 30,000ish documents that with the, you know, uh, maybe</p>\n<p>30 million interesting tokens and then how do you go from that into what are the 117 documents I really should be paying attention to in order to carry out the task that the user has asked me to do. Um and I think you know you can imag you can imagine systems where you have you know a lot of uh highly parallel processing to identify those initial 30,000 candidates maybe with very lightweight kinds of models. Um then you have some system that sort of helps you</p>\n<p>narrow down from 30,000 to the 117 uh with maybe a little bit more sophisticated um model uh or set of models. And then maybe the final model is the thing that looks at 117 things. That might be your most capable model. So I think it has to it's going to be some system like that that is really enables you to give the illusion of attending to trillions of tokens. Um sort of the way Google search gives you you know not the illusion but you are searching the internet. Yeah.</p>\n<p>>> But you're finding you know a very small subset of things that are that are relevant. >> Yeah. I I often tell a lot of people uh that are not steeped in like Google search history that uh well you know like BERT was like used like basically immediately inside of Google search uh and that improves results a lot right like I I don't I don't have any numbers off the top of my head but like I'm sure you that's obviously the most important numbers to to Google. Yeah, I mean I I think going to an LLMbased representation of text and words and so</p>\n<p>on enables you to get out of the explicit hard notion of of particular words having to be on the page, but really getting at the notion of this topic of this page or this paragraph is highly relevant to this query. >> Yeah. Yeah. I I don't think people understand how much LMS have taken over all these very high traffic system. very high traffic. Yeah, like [laughter] >> it's Google. Uh it's YouTube. Uh YouTube has this like semantics uh ID thing where there's like every token or every uh item in the vocab is a YouTube video</p>\n<p>or something that predicts the video using a code book which is absurd to me for YouTube size. And then most recently Grock also for for XAI which is like >> I mean I'll call out even before LLMs were used extensively in search we put a lot of emphasis on softening the notion of what the user actually entered into the query so that >> do you have like a history of like</p>\n<p><strong>[24:08]</strong></p>\n<p>what's the >> yeah I mean I actually gave a talk in uh I guess uh web search and data mining conference in 2009. >> Okay. uh where we never actually published any papers about the origins of Google search uh sort of but we went through sort of four or five or six generations four or five or six generations of uh redesigning of the search and retrieval system uh from about 1999 through 2004 or five and that talk is really about that evolution and one of the things that really happened in 2001 was we were</p>\n<p>sort of working to scale the system in multiple dimensions. So one is we wanted to make our index bigger so we could retrieve from a larger index which always helps your quality in general uh because if you don't have the page in your index you're going to not do well. Um and then we also needed to scale our capacity because we were our traffic was growing quite extensively. Um and so we had you know a sharded system where you have more and more shards as the index grows. you have like 30 shards and then</p>\n<p>if you want to double the index size you make 60 shards so that you can bound the latency by which you respond for any particular user query. Um and then as traffic grows you add more and more replicas of each of those. And so we eventually did the math that realized that in a data center where we had say 60 shards and um you know 20 copies of each shard we now had 1,200 machines uh with discs. and we did the math and we're like, hey, one copy of that index would actually fit in memory across,200</p>\n<p>machines. >> Mhm. >> So in 2001 we introduced uh we put our entire index in memory. >> And what that enabled from a quality perspective was amazing because before you had to be really careful about, you know, how many different terms you looked at for a query because every one of them would involve a disk seek on every one of the 60 shards. And so you as you make your index bigger, that becomes even more inefficient. But once you have the whole index in memory, it's totally fine to have 50</p>\n<p>terms you throw into the query from the user's original three or four word query because now you can add synonyms like restaurant and restaurants and cafe and uh beastro and all these things. And you can suddenly start uh sort of really uh getting at the meaning of the word as opposed to the exact semantic form. the user typed in. And that was, you know, 2001, very much preLLM, but really it was about softening the the strict definition of what the user typed in</p>\n<p>order to get at the meaning. >> What are like principles that you use to like design the systems, especially when you have I mean in 2001 the internet is like doubling tripling every year in size. It's not like a you know, and I think today you kind of see that with LLMs too where like every year the jumps in size and like capabilities are just so big. Are there just any you know principles that you use to like think about this? >> Yeah, I mean I think uh you know first</p>\n<p><strong>[27:11]</strong></p>\n<p>whenever you're designing a system you want to understand what are the sort of design parameters that are going to be most important in deciding that you know so you know how many queries per second do you need to handle? How big is the index you need to handle? How much data do you need to keep for every document in the index? How are you going to look at it when you retrieve things? um what happens if traffic were to double or triple you know will that system work well and I think a good design principle is you're want to design a system so that the most important characteristics could scale by</p>\n<p>like factors of five or 10 but probably not beyond that because >> often what happens is if you design a system for X and something suddenly becomes 100X that would enable a very different point in the design space that would not make sense at X but all of a sudden 100x makes total sense. So like going from a disk spaced index to a in-memory index makes a lot of sense once you have enough traffic because now you have enough replicas of the sort of state on disk that those machines now</p>\n<p>actually can hold uh you know a full copy of the me uh index in memory. >> Yeah. >> And that all of a sudden enables a completely different design that wouldn't have been practical before. >> Yeah. Um, so I'm I'm a big fan of thinking through designs in your head, just kind of playing with the design space a little before you actually do a lot of writing of code. But you know, as you said, in the early days of Google, we were you growing the index uh quite extensively. We were growing the update</p>\n<p>rate of the index. So the update rate actually is the parameter that changed the most surprisingly. So it used to be once a month. >> Yeah. And then we went to a system that could update any particular page in like sub one minute. >> Okay. Yeah. Because this is a competitive advantage, right? >> Because all of a sudden news related queries, you know, if you're if you've got last month's news index, it's not actually that useful for >> a special beast. Was there any like you could have split it onto a separate system? >> Well, we did we launched a Google News</p>\n<p>product, but you also want news related queries that people type into the main index to also be >> sort of updated. So, >> yeah. Yeah. It's interesting. And then you have to like classify whether the page is you have to decide which pages should be updated at what frequency. >> Oh yeah, there's a whole like uh system behind the scenes that's trying to decide update rates and importance of the pages. So even if the update rate seems low, you might still want to rec crawl important pages quite often because >> uh the likelihood they change might be low but the value of having them updated</p>\n<p>is high. >> Yeah. Yeah. Yeah. Yeah. uh what you know this uh you know mention of latency and and saving things to this reminds me of one of your classics which I have to bring up which is latency numbers every programmer should know. >> Uh >> was there was there just a just general story behind that did you just write it down? >> I mean this has like sort of eight or 10 different kinds of metrics that are like how long does a cache miss take, how</p>\n<p><strong>[30:12]</strong></p>\n<p>long does branch miss predict take, how long does a reference domain memory take, how long does a distance take these >> how long does it take to send you know a packet from the US to the Netherlands or something. Um, >> why Netherlands by the way or is it is that because of Chrome? >> Uh, we had a data center in [laughter] >> um so I mean I think this gets to the point of being able to do these back at the envelope calculations. So these are sort of the raw ingredients of those and you can use them to say okay well if I need to design a system to do image search and thumbnailing or something of</p>\n<p>the result page you know how might I do that? I could premp compute the image thumbnails. I could like try to thumbnail them on the fly from the larger images. What would that do? How much dis bandwidth I need? How many disc seeks would I do? Um and you can sort of actually do thought experiments in you know 30 seconds or a minute with the sort of uh basic uh basic numbers at your fingertips. Uh and then as you sort of build software using higher level libraries, you kind of want to develop</p>\n<p>the same intuitions for how long does it take to you know look up something in this particular kind of hash table I use or you know how long will it take me to sort a million numbers or something. >> Yeah. The the reason I bring it up actually is actually for I think like two years now I've been trying to make numbers every AI programmer should know. >> Okay. Yeah. >> Uh I don't have a great one. uh because it's not as it's not physical constants like you have physical constants in here you know it's and >> uh but I do think like uh so a simple one would be number of parameters to um</p>\n<p>uh disk size if you if you need to convert that uh which is a simple bite conversion that's not that's nothing interesting I wonder if you have any if you want if you if you were to update your >> I mean I think uh it's really good to think about uh calculations you're doing in a model either for training or inference. Um, often a good way to view that is how much uh state will you need to bring in from memory either like onchip SRAMM or</p>\n<p>HPM from the accelerator attached uh memory or DRAM or over the network. Um and then how expensive is that data motion relative to uh the cost of say an actual multiply in the matrix multiply unit >> and that cost is actually really really low right because it's you know order you know uh depending on your precision I think it's like sub pico one picole >> oh okay you measure it by energy</p>\n<p>>> yeah yeah I mean it's all going to be about energy and how do you make the most energy efficient Um, and then moving data from the SRAMM on the other side of the chip, not not even off the off chip, but on the other side of the same chip can be, you know, a thousand pajles. >> Oh. >> Or Yeah. And so all of a sudden this is</p>\n<p><strong>[33:14]</strong></p>\n<p>why your accelerators uh require batching because if you move like say the parameter of a model from SRAMM on the on the chip into the multiplier unit that's going to cost you a thousand pico tools. So you better make use of that that thing that you moved many many times with. So that's where the batch dimension comes in because all of a sudden, you know, if you have a batch of 256 or something, that's not so bad. But if you have a batch of one, that's really not good. >> Yeah. Yeah. >> Right. Because then you paid a thousand podles in order to do your one pico multiply.</p>\n<p>>> I have never heard a energy based analysis of batching. [laughter] >> Yeah. I mean, that's why people batch, right? Yeah, ideally you'd like to use batch size one because the latency would be great >> but the energy cost and the the compute cost inefficiency that you get um is is quite large. So >> yeah is there a similar trick like uh like like you did with uh you know putting everything in memory like you know I think uh obviously Nvidia has caused a lot of waves with uh betting very hard on on SRAMM with grock. Uh I I I wonder if like that's something that</p>\n<p>you already saw with with the TPUs, right? Like that that you had to uh to serve at your scale. Uh you probably sort of saw that coming like what what what hardware uh innovations or insights were formed because of what you're seeing there. >> Yeah. I mean, I think you know, TPUs have this nice uh sort of regular structure of 2D or 3D meshes with a bunch of chips connected and each one of those has HPM attached. Um I think for serving some kinds of models,</p>\n<p>>> uh you know, you you pay a lot higher cost and time latency um bringing things in from HBM than you do bringing them in from uh SRAMM on the chip. So if you have a small enough model, you can actually do model parallelism, spread it out over lots of chips, and you actually get quite good throughput improvements and latency improvements from doing that. And so you're now sort of striping your smalish scale model over say 16 or 64 chips. Uh</p>\n<p>but if if you do that and it all fits in SRAMM, uh that can be a big win. So yeah, that's not a surprise, but it is a good technique. >> Yeah. What about the TPU? design like how much do you decide where the improvements have to go? So like this is like a good example of like is there a way to bring the thousand pig jewel down jewels [clears throat] down to 50 and like is it worth designing a new chip to do that? The extreme is like when people say oh you should burn the model on the ASIC and that's kind of like the most</p>\n<p>extreme thing. >> How much of it is it worth doing in hardware when things change so quickly? Like what what's the internal discussion? Yeah, I mean we we have a lot of interaction between say the TPU chip design architecture team and the sort of higher level modeling uh experts because we really want to take advantage of being able to co-design what should future TPUs look like based on where we think the sort of ML research puck is</p>\n<p><strong>[36:16]</strong></p>\n<p>going uh in some sense because uh you know as a hardware designer for ML in particular you're trying to design a chip starting today and that design might take two years before it even lands in a data center and then it has to sort of be a reasonable lifetime of the chip to take you three, four or five years. So you're trying to predict two to six years out where what ML computations will people want to run two to six years out in a very fast changing field. And so having people with</p>\n<p>interesting ML research ideas of things we think will start to work in that time frame or will be more important in that time frame. Uh really enables us to then get you know interesting hardware features put into you know TPU N plus2 where TPUn is what we have today. >> Oh the cycle time is plus two >> roughly. I mean >> because uh >> I mean sometimes you can squeeze some changes into N plus1 but you know bigger</p>\n<p>changes are going to require the chip design be earlier in its lifetime design process. Um, so whenever we can do that, it's generally good. And sometimes you can put in speculative features that maybe won't cost you much chip area, but if it works out, it would make something, you know, 10 times as fast. And if it doesn't work out, well, you burned a little bit of tiny amount of your chip area on that thing, but it's not that big a deal. Uh, sometimes it's a very big change and we want to be pretty sure this is going to work out.</p>\n<p>So we'll do like lots of careful ML experimentation to show us uh this is actually the the way we want to go. >> Yeah. >> Is there a reverse of like we already committed to this chip design so we cannot take the model architecture that way because it doesn't quite fit? >> Yeah. Yeah, I mean you you definitely have things where you're going to adapt what the model architecture looks like so that they're efficient on the chips that you're going to have for both training and inference of that of that uh generation of model. So I think it</p>\n<p>kind of goes both ways. Um you know sometimes you can take advantage of you know lower precision things that are coming in a future generation. So you might train it at that lower precision even if the current generation doesn't quite uh do that. >> Mhm. Yeah. How low can we go in precision? >> People are saying like turner is like [laughter] >> Yeah. I mean I'm a big fan of very low precision because I think that gets that saves you a tremendous amount of energy, right? Because it's poujles per bit that</p>\n<p>you're transferring and reducing the number of bits is a really good way to >> to reduce that. Um, you know, I think people have gotten a lot of luck, uh, mileage out of having very low bit precision things, but then having scaling vectors that apply to a whole bunch of, uh, those those weights >> scaling. Okay. Interesting. You so low</p>\n<p><strong>[39:16]</strong></p>\n<p>precision but scaled up weights. >> Yeah. >> Huh. Yeah. Never considered that. Interesting. Uh while we're on this topic, you know, I think there's a lot of um uh just the concept of precision at all is weird when we're sampling, you know, uh we just at the end of this we're going to have all these like chips that all do like very good math and then we're just going to throw a random number generator at the start and [laughter] >> so I mean I there's a movement towards energy based uh models and pro processors. I'm just curious if you've obviously you've thought about it but</p>\n<p>like what's your commentary? Yeah, I mean I think there's a bunch of interesting trends. So energy based models is one. You know, diffusion based models which don't sort of sequentially decode tokens is another. >> Yes. Um, you know, speculative decoding is a way that you can get sort of an equivalent very small >> draft >> batch factor uh for like you predict eight tokens out and that enables you to sort of increase the effective batch size of what you're doing by a factor of eight even and then you maybe accept five or six of those tokens. So you get</p>\n<p>five a 5x improvement in the amortization of moving weights uh into the multipliers to do the prediction for the the tokens. So these are all really good techniques and I think it's really good to look at them from the lens of uh energy real energy not energy based models um and and also latency and throughput right if you look at things from that lens that sort of guides you to solutions that are going to be uh you</p>\n<p>know better from uh you know being able to serve larger models or you know equivalent size models more cheaply and with lower latency. >> Yeah. Well, I think I think I um it's appealing intellectually. Uh haven't seen it like really hit the mainstream, but um I do think that uh there's some poetry in the sense that uh you know, we don't have to do uh a lot of shenanigans if like we fundamentally design it into the hardware.</p>\n<p>>> Yeah. Yeah. I mean, I think there's still a there's also sort of the more exotic things like analog based uh uh computing substrates as opposed to digital ones. Uh I'm, you know, I think those are super interesting because they can be potentially low power. >> Uh but I think you often end up wanting to interface that with digital systems and you end up losing a lot of the power advantages in the digital to analog and analog to digital conversions you end up doing >> uh at the sort of boundaries and periphery of that system. M >> um I still think there's a tremendous</p>\n<p>distance we can go from where we are today in terms of energy efficiency with sort of uh much better and specialized hardware for the models we care about. >> Yeah. >> Um any other interesting research ideas that you've seen or like maybe things that you cannot pursue at Google that you would be interested in seeing researchers take a stab at? I guess you</p>\n<p><strong>[42:17]</strong></p>\n<p>have a lot of researchers. Yeah, we have a lot of our our research portfolio is [laughter] pretty broad. I would say um I mean I think [snorts] uh in terms of research directions, there's a whole bunch of uh you know open problems and how do you make these models reliable and able to do much longer kind of uh more complex tasks that have lots of subtasks? How do you orchestrate you know maybe one model that's using other models as tools in order to sort of build uh things that can accomplish uh you know much more significant pieces of</p>\n<p>work uh collectively than you would ask a single model to do. Um so that's super interesting. How do you get more verifiable uh you know how do you get RL to work for non-verifiable domains? I think it's a pretty interesting open problem because I think that would broaden out the capabilities of the models, the improvements that you're seeing in both math and coding. Uh if we could apply those to other less verifiable domains because we've come up with RL techniques that actually enable us to do that uh effectively that would</p>\n<p>that would really make the models improve quite a lot. I think >> I'm curious like when we had no brown on the podcast, he said um they already proved you can do it with deep research. Mhm. >> Um, you kind of have it with AI mode in a way. It's not verifiable. >> I'm curious if there's any thread that you think is interesting there. Like what is it? Both are like information retrieval of JSON. So I wonder if it's like the retrieval is like the verifiable part that you can score or what are like yeah how how would you</p>\n<p>model that that problem? Yeah, I mean I think there are ways of having other models that can evaluate the results of what a first model did. Maybe in retrieving, can you have another model that says, is this things are these things you retrieved relevant or can you rate these 2,00 things you retrieved to assess which ones are the 50 most relevant or something. Um, I think those kinds of techniques are actually quite effective. Sometimes that can even be the same model just prompted differently to be a you know critic as</p>\n<p>opposed to a uh actual retrieval system. >> Yeah. Um, I do think like there there is that that weird cliff where like it feels like we've done the easy stuff and then now it's but it always feels like that like every year [clears throat] it's like oh like we know you know and the next part is super hard and nobody's figured it out and >> uh like exactly with this RLVR thing where like everyone's talking about well okay how do we do the next stage of the non-verifiable stuff and everyone's like I don't know you know judge [laughter]</p>\n<p>>> I mean I feel like The nice thing about this field is there's lots and lots of smart people thinking about creative solutions to some of the, you know, problems that we all see. Uh because I think everyone sort of sees that the models, you know, are great at some things and they fall down around the edges of those things and and are not as capable as we'd like in those areas. And then coming up with good techniques and</p>\n<p><strong>[45:20]</strong></p>\n<p>trying those and seeing which ones actually make a difference is sort of what the whole research aspect of this field is is pushing forward. And I think that's why it's super interesting. You know, if you think back two years ago, we were struggling with GSM8K problems, right? Like, you know, Fred has two rabbits, he gets three more rabbits. How many rabbits does he have? >> That's a pretty far cry from the kinds of mathematics that the models can. >> And now you're doing Yeah. And erosure language. Yeah. >> Yeah. Pure language. So that is a really really amazing jump in</p>\n<p>capabilities in you know a year and a half or something. And I think um for other areas it'd be great if we could make that kind of leap. Uh and you know we don't exactly see how to do it for some some areas but we do see it for some other areas and we're going to work hard on making that better. >> Yeah. >> Yeah. Like YouTube thumbnail generation that would be very helpful. >> We need that. That would be AGI. we need for as far as content creators go. >> I guess I'm not a YouTube creator, so I don't care that much about that problem,</p>\n<p>but I guess uh many people do. >> It Yeah, it doesn't it doesn't matter. People do judge books by their covers as it turns out. >> Um just to draw a bit on the IMO gold. Um I'm still not over the fact that a year ago we had Alpha Proof and Alpha Geometry and all those things and then this year we were like screw that, we'll just chuck it into Gemini. What's your reflection? Like I think this this question about like the merger of like symbolic systems and like and and LLMs uh was a very much core belief and then</p>\n<p>somewhere along the line people just said nope we'll just all do it in LLM. >> Yeah. I mean, I think it makes a lot of sense to me because, you know, humans manipulate symbols, but we probably don't have like a symbolic representation in our heads, >> right? We have some distributed representation that is neural netlike in some way of lots of different neurons and activation patterns firing when we see certain things and that enables us to reason and plan and, you know, do</p>\n<p>chains of thought and, you know, roll them back. you know that that approach for solving the problem doesn't seem like it's going to work. I'm going to try this one. And you know, in a lot of ways, we're emulating what we intuitively think uh is happening inside real brains in neural netbased models. So it never made sense to me to have like completely separate discrete uh symbolic things and then a completely different way of of uh you know thinking about those things.</p>\n<p>>> Interesting. Yeah. Uh I mean it's maybe seems obvious to you but it wasn't obvious to me a year ago. [laughter] >> Yeah. I mean I do think like that >> IMO with you know translating to lean and using lean and then the next year and and also a specialized geometry model and then this year switching to a single unified model that is roughly the</p>\n<p><strong>[48:22]</strong></p>\n<p>production model with a little bit more inference budget uh is actually you know quite good because it shows you that the capabilities of that general model yeah have improved dramatically and and now you don't need these specialized models. This is actually sort of very similar to the 2013 to6 era of machine learning, right? Like it used to be people would train separate models for lots of different each different problem, right? I have I want to recognize street signs in something. So I train a street sign recogn recognition model or I want to you know decode speech recognition. I</p>\n<p>have a speech model. Right? I think now the era of unified models that do everything is really upon us and the question is how well do those models generalize to new things they've never been asked to do and they're getting better and better >> and you don't need domain experts like one of my uh so I interviewed Eay who was on who's on that team >> uh and he was like yeah I I don't know how they work I don't know where the IMO competition was held I don't know the rules of it I just train the models I'm good at training [laughter] models >> and it's kind of interesting thing that</p>\n<p>like people with these this like universal skill set of just like machine learning you just give them data and give them enough compute and they can kind of tackle any task which is >> yeah right [laughter] and >> a bitter lesson I guess I don't know >> yeah yeah I mean I think uh general models uh will win out over specialized ones in most cases >> so I want to push there a bit I think there's one hole here which is like uh there's this concept of like uh maybe capacity of a model like abstractly a model can only contain [clears throat] the number of bits that it has and uh</p>\n<p>and so you know god knows like Gemini Pro is like one to 10 trillion parameters we don't know but uh the Gemma models for example right like a lot of people want like the open source local models that are like that that that and and uh they have some knowledge which is not necessary right like they can't know everything like like you have the luxury of you have the big model and big model should be able to capable of everything but like when when you're distilling and you're going down to the small models,</p>\n<p>you know, you're actually memorizing things that are not useful >> and so like how do we I guess do we want to extract that? Can we can we divorce knowledge from reasoning, you know? >> Yeah. I mean, I think you do want the model to be most effective at reasoning if it can retrieve things, right? having the model devote precious parameter space to remember obscure facts that could be looked up >> is actually not the best use of that parameter space right like you might prefer something that is more generally</p>\n<p>useful in more settings than this obscure fact that it has um so I think that's always a tension at the same time you also don't want your model to be kind of completely detached from you know knowing stuff about the world right like it's probably useful to know how long the Golden Gate Bridge is just as a general sense of like how long are</p>\n<p><strong>[51:22]</strong></p>\n<p>bridges, right? And uh it should have that kind of knowledge. It maybe doesn't need to know how long some teeny little bridge in some other more obscure part of the world is, but uh it does help it to have a fair bit of world knowledge. And the bigger your model is, the more you can have. Uh but I do think combining retrieval with sort of reasoning and making the model really good at doing multiple stages of retrieval and reasoning through the intermediate retrieval results is going to be a a pretty effective way of making</p>\n<p>the models seem much more capable because if you think about say a personal Gemini >> Yeah. Right? Like we're not going to train Gemini on my email. Probably we'd rather have a single model that uh we can then use and use being able to retrieve from my email as a tool and have the model reason about it and retrieve from my photos or whatever. Uh and then make use of that and have multiple u you know stages of interaction. >> That makes sense. Do you think the</p>\n<p>vertical models are like [clears throat] an interesting pursuit? Like when people are like, \"Oh, we're building the best healthcare LLM. We're building the best law LLM.\" Are those kind of like short-term stop caps or >> No, I mean I think I think vertical models are interesting like you want them to start from a pretty good base model, but then you can sort of I sort of viewing them view them as enriching the data distribution for that particular vertical domain for healthcare. say um we're probably not going to train or for say robotics,</p>\n<p>we're probably not going to train Gemini on all possible robotics data. We you could train it on because we wanted to have a balanced set of capabilities. Um, so we'll expose it to some robotics data, but if you're trying to build a really, really good robotics model, you're going to want to start with that and then train it on more robotics data and then maybe that would hurt its multilingual translation capability but improve its robotics capabilities. And we're always making these kind of uh, you know, tradeoffs in the data mix that</p>\n<p>we train the base Gemini models on. You know, we'd love to include data from 200 more languages and as much data as we have for those languages. >> Yeah. >> But that's going to displace some other capabilities of the model. >> It won't be as good at um you know, Pearl programming. you know, it'll still be good at Python programming because we'll include enough of that, but there's other longtail computer languages or coding capabilities that it may suffer on or multi- uh multimodal reasoning capabilities may suffer</p>\n<p>because we didn't get to expose it to as much data there, but it's really good at multilingual things. So, I I think some combination of specialized models, maybe more modular models. So it'd be nice to have the capability to have those 200 languages plus this awesome robotics model plus this awesome healthcare uh module that all can be knitted together</p>\n<p><strong>[54:22]</strong></p>\n<p>to work in concert and called upon in different circumstances, right? Like if I have a health related thing, then it should enable using this health module in conjunction with the main base model to be even better at those kinds of things. >> Yeah. Installable knowledge. Yeah. Right. just [clears throat] download as a as a >> and some of that installable stuff can come from retrieval, >> but some of it probably should come from training on you know uh 100 billion tokens or a trillion tokens of health data. >> Yeah. And for listeners I think uh I will highlight the GEMA 3 end paper</p>\n<p>where they there was a little bit of that I think. >> Yeah. >> Yeah. I guess the question is like how many billions of tokens do you need to outpace the frontier model >> improvements? You know, it's like if I have to make this model better at healthcare and the main Gemini model is still improving, >> do I need 50 billion tokens? Can I do it with 100? If I need a trillion healthcare tokens, it's like they're probably not out there that you don't have, you know, I think that's really like the challenge. >> Oh, I mean, I think healthcare is a</p>\n<p>particularly challenging domain. So there's a lot of healthcare data that you know we don't have access to appropriately but there's a lot of you know uh healthcare organizations that want to train models on their own data that is not public healthcare data uh not public health but public healthare data. Um, so I think there are opportunities there to say partner with a large healthcare organization and train models for their use that are going to be, you know, more bespoke but probably uh might be better than a</p>\n<p>general model trained on say public data. >> Yeah. >> Yeah. I I believe uh by the way al this is like somewhat related to the language conversation. Uh I think one of your your favorite examples was you can put a low resource language in the context and it just learns [laughter] in context. >> Oh yeah. I think the example we used was Calamong which is truly low resource because it's only spoken by I think 120 people in the world and there's no written text. >> So >> so you can just do it that way just to get in the context. >> Yeah. [laughter]</p>\n<p>>> Yeah. But I put your whole data set in context, right? >> If you if you take a language like uh you know Somali or something there is a fair bit of Somali text in the world that uh or Ethiopian Amharic or something um you know we probably are not putting all the data from those languages into the Gemini based training. We put some of it but if you put more of it you'll improve the capabilities of those models. >> Yeah. >> So or of those languages. >> Uh yeah cool. Uh it's uh the I I have a side interest in linguistics. I I I I</p>\n<p>did a few classes in back in college and like uh part of me like if I was a linguist and I could have access to all these models I would just be asking really fundamental questions about language itself like uh one is there's one very obvious one which is superior warf like how much does like the language that you speak affect your thinking but then also there are some languages where there's just concepts that are not represented in other languages but some others many others</p>\n<p><strong>[57:22]</strong></p>\n<p>that are just duplicates right where uh there's also another paper that people love called the platonic representation where you know like the the an image of a cup is uh if you say learn a model on that and you you you have a lot of text with the word cup it eventually maps to like roughly the same place in laten space and so like that should apply to languages except where it doesn't and that's actually like very interesting differences in what humanity has discovered as concepts that maybe English doesn't have. [laughter]</p>\n<p>>> I I don't know. That's just like my my rant on languages. >> Yeah, I I did some work on a early model that fused together a languagebased model with you have, you know, nice word-based representations and then an image model where you have trained it on imageet like things. Yes. >> And then you fuse together the top layers of >> uh no this is device >> device. >> Uh the you do a little bit more training to fuse together those representations. And what you found was that if you give a novel image that is not in any of the</p>\n<p>categories in the image model it was trained on the model can often assign kind of the right c the right label to that image. Um so for example um I think uh telescope and uh binoculars were both in the training uh categories for the image model but um microscope was not. M. >> And so if you give it an image of a microscope, it actually can come up with something that's got the word microscope as the label that are designed even though it's never actually seen an image</p>\n<p>labeled that. >> Oh, that's nice. >> Yeah. >> Um, so yeah, >> useful. Uh, cool. I think there there's more general like broad questions, but like I guess what what do you uh wish you were asked more in in in general? Like you know you have such a broad scope. We've covered the hardware. covered the the models research. >> Yeah, I mean I think uh one thing that's kind of interesting is you know I I did a undergrad thesis on neural network uh training uh parallel</p>\n<p>neural network training uh back in 1990 when I got exposed to to neural nets and I always felt kind of they were the right abstraction but we just needed way more compute than we had then. So like the 32 processors in the department parallel computer you know could get you a a little bit more interesting uh model but not not enough to solve real problems. And so starting in 2008 or nine, you know, the world started to have enough computing power through Moors law and, you know, larger interesting data sets to train on to</p>\n<p>actually, you know, start training neural nets that could tackle real problems that people cared about, speech recognition, vision, and eventually language. Um and so um when I started working on neural nets at Google in in late 2011 um you know I really just felt like we should scale up the size of neural</p>\n<p><strong>[60:24]</strong></p>\n<p>networks we can train using you know large amounts of parallel computation and so I actually revived some ideas for my undergrad thesis where I'd done both model parallel and data parallel uh training and I compared them. >> I called them something different. It was like pattern partitioned and you know model partitioned or something. >> We'll have to Is it is it public? Can we go dig? >> Yeah, it's on it's on the web. >> Okay. >> Um but uh you know I think combining a lot of those techniques and really just trying to push on scaling things up over the last you know 15 years has been you</p>\n<p>know really important and that means you know improvements in the hardware. So you know pushing on building specialized hardware like TPUs. Uh it also means you know pushing on software abstraction layers to let people express ML ideas uh effectively. Um and then also working on things like uh say sparse models. I've felt for a long time that sort of sparsely activated models are a really important thing because you want the models to have a lot of capacity to our</p>\n<p>earlier discussion about remembering a lot of stuff. >> Yeah. >> But you also want to be super efficient in how you activate your models. So you'd like you know trillions of parameters but activate only you know one 1% or 5% or 10% of that and um that you know we did a early u paper on this where we really scaled up uh you know outrageously large neural networks that the title I think that's Nome's uh Gnome's wording in the title which is a</p>\n<p>good catchy title. >> I mean in 2017 he was out there talking about one trillion parameter models. >> Yeah. So I mean that that that is really good because that gave you like a 10x improvement in you know time to quality or compute cost to qual a given quality level relative to non-sparse models. Um transformers similarly gave you a 10x to 100x improvement in you know uh compute cost to a given quality level uh versus say LSTMs at the time and all of those things multiply together. Um so I think</p>\n<p>all those things really are important to work on you know the hardware the systems infrastructure the you know algorithmic aspects of model architecture improving the data you know improving the RL recipes all these things uh are what are stacking together and multiplying together >> to give us models of 2026 are much more better than models of 25 and are awesomely better than 24 and 23 and</p>\n<p>and and a huge uh honestly like organizational challenge like there's like a thousand people or maybe more like I know I know when the first Gemini paper came out it was like a thousand of co-authors. >> Yeah. Yeah. We have uh 10 pages of co-authors in the in the tech [laughter] report >> but it was nice. I mean you know people want to be acknowledged on probably a historical paper. >> Yeah. I mean, I think it's perfectly good to have actually a lot of co-authors and I do think >> organizing that number of people so that</p>\n<p><strong>[63:25]</strong></p>\n<p>they're effectively pushing in common directions that all all their work actually sort of multiplies together in the ultimate output which is you know the next generation of model is actually pretty tricky and we have awesome people uh throughout the Gemini team to help orchestrate this. So you know myself, Noom and Oral are sort of helping steer this and then we have people thinking about you know what is the pre-training uh setup look like what does the infrastructure look like what does the post-raining recipe look like and what</p>\n<p>does the data preparation and eval multimodal capabilities and IN capabilities >> um you know there's a lot of different kinds of areas coding capabilities all these areas are are super important and it's really good to have people uh paying close attention to those things and then also paying close attention to all the other things. >> Yeah. I'm told Sergey is like very actively back and like very much involved in coding stuff. >> Yep. Yeah. Yeah. Yeah. We all use the same micro kitchen.</p>\n<p>>> Yeah. Uh oh. Okay. Like there's so many jumping off point. Uh so by the way I found out from the recent uh I mean you've probably told this story a few times but apparently Google brain was also started in a micro kitchen. >> Yeah. Yeah. [laughter] >> Just like your micro kitchens are very important. >> Yeah. I don't know if people like understand. >> Yeah. Uh yeah, I actually bumped into Andrew Ing who's a Stanford faculty member and uh I knew him from I'd given talks at Stanford a couple years before so I sort of knew him and I'm like, \"Oh, what are you doing here?\" He's like, \"Oh, I'm not sure yet. I just started,</p>\n<p>you know, a couple weeks ago. I'm going to spend one day a week here consulting. Um I'm not sure what I'm working on, but my students at Stanford are starting to get good results um on using u neural nets for speech uh recognition. I'm like, \"Oh, neural nets. I like neural nets.\" Like I remembered back to my 1990 thesis. I'm like, \"Oh, that sounds interesting. We should train really really big neural nets.\" >> So [snorts] that was the >> which you say that and that's a very interesting first instinct, which is that we should scale this up a lot. >> Yeah. Well, I mean, I felt like</p>\n<p>Google is is has lots of computational uh capability and so if they were seeing good results on, you know, what were effectively single GPU or uh models, >> you know, if we were uh we actually didn't have GPUs in our data centers then we didn't have any accelerators. We had lots of CPUs, but you know, we could build a software system that would enable you to distribute with both model parallelism and data parallelism across lots of computers. And we ended up</p>\n<p>training a pretty big model was 50x bigger than any previous neural net as far as we could tell. Um, so it's two billion parameters uh vision model uh trained on 16,000 CPU cores for like multiple weeks. Uh and that's what gave us really good it would gave us a 70% relative error improvement in imageet 22k which is the 22,000 category thing and that's how we really saw okay</p>\n<p><strong>[66:27]</strong></p>\n<p>scaling this up actually matters. We didn't write a, you know, a sophisticated scaling analysis, but we had a a saying, bigger model, more data, better results. >> And that was our our mantra for like six or seven years of scaling. And we every time we did that, we saw better results in speech, in language, in in vision. >> Uh, speaking of um bets, and this might and this, you know, I'll preface with like this might be a little bit more sensitive topic, but you have obviously a lot of opinions about this. We had a previous guest, David Juan, who used to</p>\n<p>work for you, and uh he he kind of like blames almost the brain marketplace as like the reason that Google didn't invest enough in language models. And I wonder if that's uh something you would you would agree with at the time or uh is there like a different sort of postmortm >> the brain marketplace for computers >> compute quotas where basically he was like okay the like >> David worked at OpenAI as VP engine then he worked at Google he was like fundamentally open was willing to go all in like bet the farm on one thing</p>\n<p>whereas Google was more democratic like everyone had a >> had a quota and I was like okay like like if if you believe in scaling as an important thing that's a that's an important organizationalwide decision to do. >> Yeah. Uh yeah, I mean I think uh I would somewhat agree with that. I mean I think I actually wrote a one-page memo saying we were being stupid by uh fragmenting our resources. >> Um so in particular at the time we had uh you know uh efforts within Google</p>\n<p>research on uh and and in the brain team in particular on large language models. We also had efforts on multimodal models um in uh other parts of brain and and Google research and then legacy deep mind had uh efforts like um chinchilla models and uh flamingo models. Uh and so really we were fragmenting not only our compute uh across those separate efforts but also our best people and our best</p>\n<p>ideas, right? And so I said this is just stupid. Why don't we combine things and have one effort to uh train >> and this is the merge. Yeah. >> To train an awesome single unified model that is multimodal from the start that's good at everything and that was the origin of the Gemini effort and my one page memo worked which is good. >> Did you have the name because also for those who don't know you named Gemini. >> I did. Yeah. [laughter] Yeah. There was there was another name proposed and I I said, you know, it's sort of like these</p>\n<p>two organizations really are like uh twins >> in some sense coming together. Um so I kind of like that. And then there's also the NASA interpretation of you know the early Gemini project >> uh being an important thing on your way to um you know the Apollo project. So it seemed like a good name. Twins coming together,</p>\n<p><strong>[69:27]</strong></p>\n<p>>> right? Yeah. Nice. Um, I know we're already running out of time, but I'm curious how you use AI today to code. So, I mean, you're probably one of the most prolific engineers in the history of computer science. Um, I was reading on through the article about you and Sanji's friendship and how you work together [clears throat] and >> you have one quote about you need to find someone that you're going to pair program with who's compatible with your way of thinking so that the two of you together are a complimentary force. Mhm. >> And I was thinking about how you think about coding agents in this like how do you shape</p>\n<p>>> a coding agents to be compatible with your way of thinking like h how would you rate the tools today? Like where should things go? >> Yeah. I mean first I think the coding tools are you know getting vastly better compared to where they were a year or two two years ago. So now you can actually rely on them to do more complex things that you as a as a software engineer want to accomplish and you can sort of delegate you know pretty complex things to these tools. And I think one really nice aspect about the uh interaction between a a human uh</p>\n<p>software engineer and a a coding model that they're working with is your way of talking to that uh coding model actually sort of uh dictates how it interacts with you, right? Like you could ask it please write a bunch of good tests for this. You could ask it, please help me brainstorm performance ideas. And your way of doing that is going to shape how the model responds, what kinds of problems it tackles. You know, how much</p>\n<p>do you want the model to go off and do things that are larger and more independent versus interact with it more to make sure that you're shaping the right kinds of of things? And I think it's not the case that any one style is the right thing for everything, right? like some kinds of problems you actually want uh maybe a more frequent interaction style with the model and other ones you're just like, \"Yeah, please just go write this cuz I I know I need this thing. I can specify it well enough.\" Um and go off and do it and come back when you're done. And so I do</p>\n<p>think there's going to be more of a style of having lots of independent uh software agents off doing things on your behalf and figuring out the right sort of human computer interaction model and UI and so on for when should it interrupt you and say hey I need a little more guidance here or I've done this thing now what now what should I do? Um I think we we're not at the end all answer to that question and as the models get better that uh set of decisions you put into how the interaction should happen may may change</p>\n<p>right like if you if you have a team of 50 interns how would you manage that if they were people and I think it's not >> do you want 50 interns [laughter] >> you might if they're really good right >> it's a lot of management >> but but it's a lot of Uh yeah, I mean I think that is probably</p>\n<p><strong>[72:29]</strong></p>\n<p>within the realm of possibilities that lots of people could have 50 interns >> and so how would you actually deal with that as a person, right? Like you would probably want them to form small sub teams so you don't have to interact with 50 of them. You could interact with five of five of those teams and they're off doing things on your behalf. But I don't know exactly what the how this is going to unfold. >> Yeah. How do you think about bringing people like the pair programming is always helpful to like get net new ideas in the distribution so to speak? It</p>\n<p>feels as we have more of these coding agents write the code. It's hard to bring other people into the problem. Say you go to like you know you have 50 interns [clears throat] right and then you want to go to nom shazir be like hey nom I want to like pair on this thing >> but now there's like this huge amount of work that has been done in parallel that you need to catch him up on >> right >> and I'm curious like if people are going to be in a way more isolated in their teams where it's like okay there's so much context in these 50 interns that it's just hard for me to like relay everything back to you</p>\n<p>>> maybe I mean on the other hand like imagine a classical software or organization without any AI assisted tools, right? You would have, you know, 50 people doing stuff and their interaction style is going to be naturally very hierarchical because, you know, these 50 people are going to be working on this part of the system and not interact that much with these other people over here. But if you have, you know, five people each managing 50 virtual agents, you know, they might be</p>\n<p>able to actually have much higher bandwidth communication among the five people uh than you would have among five people who are also trying to coordinate, you know, a 50 person software team each. Yeah. So, >> how do you I'm curious how you change your just working rhythm, you know, like do you spend more time ahead with people going through specs and design goals like >> um I mean I do think it's interesting that you know whenever people were taught how to write software they were taught that it's really important to</p>\n<p>write specifications super clearly. But no one really believed that. Like it was like yeah whatever I don't need to do that I'm going to [laughter] >> really >> I don't know. I mean, writing the English the English language specification was never kind of an artifact that was really paid a lot of attention to. I mean, it was important, but it wasn't sort of the thing that drove the actual creative process quite as much as if you specify what software you want the agent to write for you, you'd better be pretty darn careful in how you specify that</p>\n<p>because that's going to dictate the quality of the output, right? like if you if you don't cover that it needs to handle this kind of thing or that this is a super important corner case or that you know you really care about the performance of this part of it you know it may uh not do what you want and the better you get at interacting with these models and and I think one of the ways</p>\n<p><strong>[75:30]</strong></p>\n<p>people will get better is they will get really good at crisply specifying things rather than leaving things to ambiguity >> and that is actually probably not a bad It's not a bad skill to have regardless of whether you're a software engineer or a you know trying to do some other kind of uh task. You know, being able to crisply specify what it is you want. It's going to be really important. >> Yeah. My joke is um you know, good prompting [clears throat] is in uh indistinguishable from sufficially advanced executive communication. Like it's like writing an internal memo. Like</p>\n<p>>> Yeah. Yeah. >> Weigh your words very carefully. And also I think very important to be multimodal, right? I think one thing that anti-gravity from from Google also did was like just come out the gate very very strong multimodal including videos and that's the highest bandwidth communication prompt that you can give the >> the model which is fantastic. >> Yeah. >> How do you collect things that you often you would have in your mind. So you have this amazing like performance hints thing that you wrote about how to look for performance improvements and is there a lot more value in like people writing these like generic things down</p>\n<p>so that they can then put them back as like potential retrieval artifacts for the model like or do I have like the edge cases is like a good example right it's like [snorts] if you're building systems you already have in your mind specific edge cases depending on it but now you have to like every time repeat it >> like are you having people spend a lot more I'm writing out more generic things to bring back or >> um I mean [snorts] I do think [clears throat] well-written guides of of how to do good software engineering are going to be useful because they can</p>\n<p>be used as input to models or you know read by other developers so that their prompts are you know more clear about what the the underlying software system should should be doing. Um, you know, I think it may not be that you need to create a custom one for every situation. If you have general guides and put those into, you know, the context of a coding agent that that can be helpful like in you can imagine one for distributed</p>\n<p>systems. You could say, okay, think about failures of these kinds of things and these are some techniques you can deal with failures. you know, you can have uh, you know, Paxos like replication or, you know, you can, uh, send the request to two places and tolerate failure because you only need one of them to come back. You know, a little description of 20 techniques like that in building distributed systems probably would go a long way to having a coding agent be able to sort of cobble up more reliable and robust distributed systems.</p>\n<p>>> Yeah. Yeah. [clears throat] Wonder when Gemini will be able to build spanner, >> right? Probably already has the code inside, you know. [laughter] >> Yeah, that I mean that's a good example, right? When you have like you know the cap theorem and it's like well this is like truth and you cannot break that and then you build something that broke it. Like I'm curious like models in a way are like [clears throat] what did he say he broke it? Would you say you broke cat</p>\n<p><strong>[78:31]</strong></p>\n<p>theorem? >> Really? Yeah. Okay. All right. >> I mean [laughter] >> under local assumptions. Yeah. And some and they're like, you know, good clocks. >> Yeah. [laughter] It's like some sometimes you don't have to like always follow what is known to be true. And I I think models in a way like if you tell them something, they like really buy into that, you know. Um >> so yeah, just more thinking than any answer on how to fix that. Yeah, my my uh you know just on this like like big prompting and and uh iteration you know I think that coming back to your latency</p>\n<p>point um I always I always trying to one one AB test or experiment or benchmark or research I would like is what is the uh performance difference between let's say three dumb fast model calls with human alignment because the human will correct >> human alignment means the human looks at the first one and produces a new prompt for the second one as opposed to like you [clears throat] spec it out, you know, you spend a long time writing a pro a big big fat prompt and then you have a very smart model do it, right? You know, because uh really is is our</p>\n<p>lacks in performance uh an issue of like, well, you just haven't specified well enough. There's no universe in which I can produce what you want because you just haven't told me, >> right? It's underspecified. So, I could produce 10 different things and only one of them is the thing you wanted. >> Yeah. And the multi-turn taking with a flash model is enough. >> Yeah. [laughter] >> Yeah. I'm I'm a big believer in pushing on latency because I think being able to have really low latency interactions with a system you're using is just much more delightful than something that is,</p>\n<p>you know, 10 times as slow or 20 times as slow. And I think, you know, in the future, we'll see models that are and and underlying software and hardware systems that are 20x lower latency than what we have today, 50x lower latency. And that's going to be really really important for systems that need to do a lot of stuff uh between your interactions. >> Yeah. Yeah. There's two extremes, right? And then meanwhile [clears throat] you also have deep think which is all the way on the other side, >> right? [laughter] But you would use deep think all the time if it weren't for</p>\n<p>cost and latency, right? If if you could have that capability in a model because the latency improvement was 20x uh in the underlying hardware and system and costs, you know, there's no reason you wouldn't want that. >> Yeah. But at the same time, then you'd probably have a model that is even better that would take you 20 times longer even on that new hardware. >> Yeah. Uh you know that there's the Fredo curve keeps climbing. Um >> yeah,</p>\n<p>>> onward and outward. on way. [laughter] >> Yeah. Should we ask him for predictions to to go? I don't know if you have any >> predictions that you that you like to keep, you know, like uh one one way to do this is you have your tests whenever a a new model comes out that you run. Uh what's something that you're not quite happy with yet that you think will get done soon? >> Um let me make two predictions that are not</p>\n<p><strong>[81:33]</strong></p>\n<p>quite in that vein. >> Yeah. So I think a personalized model that knows you and knows all your state and is able to retrieve over all state you have access to that you opt into is going to be incredibly useful compared to a more generic model that doesn't have access to that. So like can something attend to everything I've ever seen, every email, every photo, every video I've watched. That's going to be really useful. uh I think uh more and more specialized hardware is going to enable much lower latency models and</p>\n<p>much more capable models for affordable prices uh than say the current current status quo. Uh that's going to be also quite important. >> Yeah. When you say much lower latency, uh people usually talk in tokens per second. Is that a term that is okay? Okay. Uh you know [clears throat] we're at let's say 100 now. Yeah, we can go to the thousands. Is it meaningful to go 10 thousands? >> Yes. >> Really? Okay. >> Absolutely. Right. >> Yeah. Because of chain of thought and all</p>\n<p>>> chain of thought reasoning. I mean you could think you know uh many more tokens. You could do many more parallel rollouts. You could generate way more code uh and check that the code is correct with uh chain of thought reasoning. So I think you know being able to do that at 10,000 tokens per second would be awesome. >> Yeah. At 10,000 tokens per second you are no longer reading code. Yeah. like you'll just generate it. You'll not remember it may not it may not >> end up with 10,000 tokens of code a thousand tokens of code that with 9,000 tokens of reasoning behind it.</p>\n<p>>> Yeah. Yeah. >> Which would actually be probably much better code to read. >> Yeah. Yeah. >> Yeah. If I had more time, I would have written a shorter letter. >> Yeah. Yeah. >> Um awesome, Jeff. This was amazing. Thanks for making the time. >> Thank you. It's been it's been fun. Thanks for having me. >> [music]</p>"}